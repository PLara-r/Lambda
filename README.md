# Predicate OCP4

1)Predicate - на примере

начинаем с Animalкласса:
public class Animal { 
 private String species;
  private boolean canHop;  
private boolean canSwim;  
public Animal(String speciesName, boolean hopper, boolean swimmer) {   
 species = speciesName;   
 canHop = hopper;    
canSwim = swimmer; 
 }  
 public boolean canHop() { return canHop; }   
public boolean canSwim() { return canSwim; }
   public String toString() { return species; 
}}
У Animalкласса есть три переменных экземпляра, которые задаются в конструкторе. У него есть два метода, позволяющие определить, может ли животное прыгать или плавать.
У этого также есть toString()метод, таким образом, мы можем легко идентифицировать Animalв программах.

добавляем маin
public static void main(String[] args) {
        List<Animal> animals = new ArrayList<Animal>();
            animals.add(new Animal("fish", false, true));
             animals.add(new Animal("kangaroo", true, false));
             animals.add(new Animal("rabbit", true, false));
            animals.add(new Animal("turtle", false, true));


        print(animals, a -> a.canHop());
    }
    private static void print(List<Animal> animals, Predicate<Animal> checker) {
        for (Animal animal : animals) {
            if (checker.test(animal))
                System.out.print(animal + " ");
        }
        System.out.println();
    }
}

строка 31 print(animals, a -> a.canHop());здесь мы говорим Java, что нам важны только те, Animalкоторые могут прыгать

В нашем предыдущем примере мы создали интерфейс с одним методом:(когда не использовали лямбды), интерфейс определял методы, которые должен реализовать наш класс:


public interface CheckTrait {
  boolean test(Animal a);
}



Лямбды работают с интерфейсами, которые имеют только один метод. Это так называемые функциональные интерфейсы - интерфейсы,
которые можно использовать с функциональным программированием. Java предоставляет нам такой интерфейс. Это в упаковке, java.util.functionи суть этого заключается в следующем:

public interface Predicate<T> {
  boolean test(T t);
}
Это очень похоже на наш метод. Разница лишь в том, что он использует этот тип T вместо Animal. Это синтаксис для дженериков.
Это как когда мы создали ArrayListи должны указать любой тип, который входит в него

print()Способ по линии 31 здесь проверяет не любой признак, а тех животных которые прыгают. 
Выводит список этих животных (кенгуру и заяц)
 
2) Понимание лямбда-синтаксиса
 
 
Синтаксис лямбда-выражений сложен, потому что многие части являются необязательными. Эти две строки эквивалентны и делают одно и то же:
a -> a.canHop()
 (Animal a) -> { return a.canHop(); }
Давайте посмотрим, что здесь происходит. Левая часть оператора стрелки ->указывает входные параметры для лямбда-выражения. Он может использоваться функциональным интерфейсом, чей абстрактный метод имеет одинаковое количество параметров и совместимых типов данных. Правая сторона упоминается как тело лямбда-выражения. Он может использоваться функциональным интерфейсом, абстрактный метод которого возвращает совместимый тип данных.
Поскольку синтаксис этих двух выражений немного отличается, давайте рассмотрим их более подробно. Первый пример, показанный на рисунке 2.1 , состоит из трех частей:
•	Мы указываем один параметр с именем a.
•	Оператор со стрелкой →отделяет параметр от тела.
•	Тело вызывает единственный метод и возвращает результат этого метода.
Рисунок 2.1 Лямбда-синтаксис, пропускающий необязательные части
Второй пример также состоит из трех частей, как показано на рисунке 2.2 ; это просто более многословно:
•	Мы указываем один параметр с именем aи состоянием, которое является типом Animal, заключая входные параметры в скобки ().
•	Оператор со стрелкой −>отделяет параметр от тела.
•	В теле есть одна или несколько строк кода, включая фигурные скобки {}, точку с запятой ;и returnинструкцию.
Рисунок 2.2 Лямбда-синтаксис, включая дополнительные части
Давайте рассмотрим некоторые различия между этими двумя цифрами. Первое отличие, которое вы можете заметить, состоит в том, что на рисунке 2.2 используются скобки (), а на рисунке 2.1 - нет. Круглые скобки ()могут быть опущены в лямбда-выражении, если имеется ровно один входной параметр и тип явно не указан в выражении. Это означает, что для выражений, которые имеют ноль или более одного входного параметра, по-прежнему требуются скобки. Например, ниже приведены допустимые лямбда-выражения, при условии, что существуют допустимые функциональные интерфейсы, которые могут их использовать:

() -> new Duck()
d -> {return d.quack();}
(Duck d) -> d.quack()
(Animal a, Duck d) -> d.quack()
Первое лямбда-выражение может использоваться функциональным интерфейсом, содержащим метод, который не принимает аргументов и возвращает Duckобъект. Второе и третье лямбда-выражения могут использоваться функциональным интерфейсом, который принимает в Duckкачестве входных данных a и возвращает любой тип возвращаемого значения quack(). Последнее лямбда-выражение может использоваться функциональным интерфейсом, который принимает в качестве входных данных Animalи Duckобъектов и возвращает любой возвращаемый тип quack().  
Обнаружение недействительных лямбд
Можете ли вы выяснить, почему каждое из следующих лямбда-выражений недопустимо и не будет компилироваться при использовании в качестве аргумента метода?

Duck d -> d.quack()                  // DOES NOT COMPILE
a,d -> d.quack()                     // DOES NOT COMPILE
Animal a, Duck d -> d.quack()        // DOES NOT COMPILE
Каждый из них требует скобок ()! Как мы уже говорили, круглые скобки могут быть опущены, только если есть только один параметр и тип данных не указан.
Далее, вы видите, что на рисунке 2.2 есть пара фигурных скобок {}вокруг тела лямбда-выражения. Это позволяет вам написать несколько строк кода в теле лямбда-выражения, как это можно сделать при работе с ifоператором или whileциклом. Хитрость заключается в том, что когда вы добавляете фигурные скобки {}, вы должны явно завершать каждое утверждение в теле точкой с запятой ;.
На рисунке 2.1 мы смогли опустить фигурные скобки {}, точку с запятой ;и returnоператор, потому что это специальный ярлык, который Java допускает для однострочных лямбда-тел. Этот специальный ярлык не работает, если у вас есть два или более операторов. По крайней мере, это согласуется с использованием {}для создания блоков кода в другом месте в Java. При использовании {}в теле лямбда-выражения вы должны использовать returnоператор, если метод функционального интерфейса, который реализует лямбда, возвращает значение. Кроме того, returnоператор является необязательным, если тип возвращаемого значения метода void.
Давайте посмотрим на еще несколько примеров:

() -> true                                       // 0 parameters
a -> {return a.startsWith("test");}              // 1 parameter
(String a) -> a.startsWith("test")               // 1 parameter
(int x) -> {}                                    // 1 parameter
(int y) -> {return;}                             // 1 parameter
Первый пример не принимает аргументов и всегда возвращает true. Второй и третий примеры оба принимают одно Stringзначение, используя разный синтаксис для выполнения одной и той же вещи. Обратите внимание, что в первых двух примерах мы смешали и сопоставили синтаксис между рисунками 2.1 и 2.2 , указав в первом примере круглые скобки, ()но без скобок, {}и изменили их во втором примере. Последние два примера эквивалентны, потому что они принимают целочисленное значение и ничего не возвращают.
Теперь давайте посмотрим на некоторые лямбда-выражения, которые принимают более одного параметра:

(a, b) -> a.startsWith("test")                   // 2 parameters
(String a, String b) -> a.startsWith("test")     // 2 parameters
Оба эти примера принимают два параметра и игнорируют один из них, поскольку нет правила, согласно которому лямбда-выражение должно использовать все входные параметры.
Давайте рассмотрим некоторые дополнительные лямбда-выражения, чтобы увидеть, как развивается ваше понимание лямбда-синтаксиса. Вы видите, что не так с каждым из этих лямбда-выражений?

a, b -> a.startsWith("test")                 // DOES NOT COMPILE
c -> return 10;                              // DOES NOT COMPILE
a -> { return a.startsWith("test") }         // DOES NOT COMPILE
Первая лямбда нуждается в скобках ()вокруг списка параметров. Помните, что круглые скобки являются необязательными, только когда есть один параметр, и у него нет объявленного типа. Во второй строке используется returnключевое слово без скобок {}. В последней строке пропущена точка с запятой после returnоператора. Следующие переписанные лямбда-выражения допустимы:

(a, b) -> a.startsWith("test")
c -> { return 10; }
a -> { return a.startsWith("test"); }
Как уже упоминалось, типы данных для входных параметров лямбда-выражения являются необязательными. Однако, если для одного параметра указан тип данных, все параметры должны предоставлять тип данных. Следующие лямбда-выражения недопустимы по этой причине:

(int y, z) -> {int x=1; return y+10; }       // DOES NOT COMPILE
(String s, z) -> { return s.length()+z; }    // DOES NOT COMPILE
(a, Animal b, c) -> a.getName()              // DOES NOT COMPILE
Если мы добавим или удалим все типы данных, то эти лямбда-выражения будут компилироваться. Например, допустимы следующие переписанные лямбда-выражения:

(y, z) -> {int x=1; return y+10; }
(String s, int z) -> { return s.length()+z; }
(a, b, c) -> a.getName()
Есть еще одна проблема, которую вы можете увидеть с лямбдами. Мы определяли список аргументов в наших лямбда-выражениях. Поскольку Java не позволяет нам повторно объявлять локальную переменную, проблема заключается в следующем:

(a, b) -> { int a = 0; return 5;}            // DOES NOT COMPILE
Мы пытались повторно заявить a, что не разрешено. В отличие от этого, разрешается использовать следующую строку, поскольку она использует другое имя переменной:

(a, b) -> { int c = 0; return 5;}


3) Встроенные функциональные интерфейсы

 Работа со встроенными функциональными интерфейсами – 2 раздел
Как вы помните, функциональный интерфейс имеет ровно один абстрактный метод. Все функциональные интерфейсы в Таблице 4.1 были введены в Java 8 и представлены в   java.util.functionпакете. Соглашение здесь заключается в использовании универсального типа Tдля параметра типа. Если требуется параметр второго типа, используется следующая буква U,. Если требуется отдельный тип возврата, Rдля возврата используется универсальный тип.
Таблица 4.1 Общие функциональные интерфейсы

Functional Interfaces                 # Parameters            Return Type                        Single Abstract Method
Supplier<T>                                       0                                  T                                             get
Consumer<T>                                 1 (T)                                void                                     accept
BiConsumer<T, U>                         2 (T, U)                             void                                    accept
Predicate<T>                                   1 (T)                              Boolean                                     test
BiPredicate<T, U>                                2 (T, U)                       Boolean                                   test
Function<T, R>                                 1 (T)                               R                                              apply
BiFunction<T, U, R>                            2 (T, U)                             R                                         apply
UnaryOperator<T>                               1 (T)                              T                                            apply
BinaryOperator<T>2                              (T, T)                           T                                             apply
Многие другие функциональные интерфейсы определены в java.util.functionпакете. Они предназначены для работы с примитивами, что вы увидите позже в этой главе.
Вам нужно запомнить эту таблицу. Мы дадим вам много практики в этом разделе, чтобы сделать это запоминающимся. Прежде чем спросить, большую часть времени мы фактически не назначаем реализацию интерфейса переменной. Подразумевается имя интерфейса, и оно передается непосредственно нужному методу. Мы вводим имена, чтобы вы могли лучше понять и запомнить, что происходит. Как только мы перейдем к части, посвященной потокам, мы предположим, что у вас есть это, и прекратим создание промежуточной переменной.
Как вы видели в главе 2, вы можете назвать функциональный интерфейс как угодно. Единственными требованиями является то, что оно должно быть допустимым именем интерфейса и содержать один абстрактный метод. Таблица 4.1 важна, поскольку эти интерфейсы часто используются в потоках и других классах, которые поставляются с Java, поэтому вам необходимо запомнить их для экзамена.
Как вы узнаете в главе 7, есть интерфейс с названием Runnable. Он используется для параллелизма в большинстве случаев. Однако он может появиться на экзамене, когда вас попросят определить, какой функциональный интерфейс использовать. Все, что вам нужно знать, это то, что Runnableон не принимает никаких параметров, не возвращает никаких данных и не использует обобщенные значения.
Давайте посмотрим, как реализовать каждый из этих интерфейсов. Поскольку и лямбда-выражения, и ссылки на методы появляются повсюду, мы показываем реализацию, где это возможно.  
Внедряющий поставщик
А Supplierиспользуется, когда вы хотите генерировать или предоставлять значения без каких-либо входных данных. SupplierИнтерфейс определяется как

@FunctionalInterface public class Supplier<T> {  
 public T get();
}
На ОСА вы узнали, что можете создать дату, используя фабрику. Если вы забыли как, не волнуйтесь. Мы рассмотрим это снова в главе 5 «Даты, строки и локализация» в этой книге. Вы можете использовать Supplierдля вызова этой фабрики:

Supplier<LocalDate> s1 = LocalDate::now;
Supplier<LocalDate> s2 = () -> LocalDate.now(); 
LocalDate d1 = s1.get();
LocalDate d2 = s2.get(); 
System.out.println(d1);
System.out.println(d2);
В этом примере печатается дата, например, 2015–06–20дважды. Это также хорошая возможность просмотреть ссылки на статические методы. LocalDate::nowЭталонный метод используется для создания Supplierдля назначения промежуточной переменной s1. А Supplierчасто используется при создании новых объектов. Например, мы можем вывести два пустых StringBuilders:

Supplier<StringBuilder> s1 = StringBuilder::new;
Supplier<StringBuilder> s2 = () -> new StringBuilder(); 
System.out.println(s1.get());
System.out.println(s2.get());
На этот раз мы используем ссылку на конструктор для создания объекта. Мы использовали дженерики, чтобы объявить, какой тип Supplierмы используем. Это может быть немного долго читать. Можете ли вы выяснить, что делает следующее? Просто сделайте один шаг за раз.

Supplier<ArrayList<String>> s1 = ArrayList<String>::new;
ArrayList<String> a1 = s1.get();
System.out.println(a1);
У нас Supplierесть определенный тип. Этот тип случается ArrayList<String>. Затем вызов get()создает новый экземпляр ArrayList<String>, который является универсальным типом Supplier- другими словами, универсальным, который содержит другой универсальный. Это не сложно понять, поэтому просто внимательно посмотрите на код, когда появятся подобные вещи.
Обратите внимание, как мы вызывали get()функциональный интерфейс. Что будет, если мы попытаемся распечатать s1себя?
System.out.println(s1); печатает что-то вроде этого:

functionalinterface.BuiltIns$$Lambda$1/791452441@1fb3ebeb
Это результат вызова toString()лямбды. Тьфу. Это действительно что-то значит. Наш тестовый класс назван BuiltIns, и он находится в пакете, который мы создали по имени functionalinterface. Затем следует $$, что означает, что класс не существует в файле класса в файловой системе. Он существует только в памяти. Вам не нужно беспокоиться об остальном.
  Реализация Consumer и BiConsumer
Вы используете, Consumerкогда хотите что-то сделать с параметром, но ничего не возвращаете. BiConsumerделает то же самое, за исключением того, что он принимает два параметра. Опуская defaultметоды, интерфейсы определяются следующим образом:

@FunctionalInterface public class Consumer<T> {  
 void accept(T t);
}
@FunctionalInterface public class BiConsumer<T, U> { 
  void accept(T t, U u);
}
Вы заметите эту модель. Би означает два. Это происходит от латинского, но вы можете вспомнить его из английских слов, таких как двоичный (0 или 1) или велосипед (два колеса). Всегда добавляйте другой параметр, когда вы видите, как появляется Би .
Вы использовали Consumerв главе 3 с forEach. Вот тот пример, фактически назначаемый Consumerинтерфейсу:

Consumer<String> c1 =  System.out::println;
Consumer<String> c2 = x -> System.out.println(x);
 c1.accept("Annie");
c2.accept("Annie");
Этот пример печатается Annieдважды. Вы можете заметить, что в Consumerпримерах использовалась ссылка на метод System.out::println. Это нормально. Java использует контекст лямбды, чтобы определить, какой перегруженный println()метод следует вызывать.
BiConsumerвызывается с двумя параметрами. Они не должны быть одного типа. Например, мы можем поместить ключ и значение в карту, используя этот интерфейс:

Map<String, Integer> map = new HashMap<>();
BiConsumer<String, Integer> b1 =  map::put;
BiConsumer<String, Integer> b2 = (k, v) -> map.put(k, v); 
b1.accept("chicken", 7);
b2.accept("chick", 1); 
System.out.println(map);
Вывод {chicken=7, chick=1}, который показывает, что обе BiConsumerреализации были вызваны. На этот раз мы использовали ссылку на метод экземпляра, так как мы хотим вызвать метод локальной переменной map. Кроме того, мы впервые передали два параметра в ссылку на метод. Код для создания экземпляра b1немного короче, чем код для b2. Вероятно, поэтому экзамен так любит ссылки на методы.
В качестве другого примера мы используем один и тот же тип для обоих общих параметров:

Map<String, String> map = new HashMap<>();
BiConsumer<String, String> b1 =  map::put;
BiConsumer<String, String> b2 = (k, v) -> map.put(k, v);
 b1.accept("chicken", "Cluck");
b2.accept("chick", "Tweep");
 System.out.println(map);
Выходные данные {chicken=Cluck, chick=Tweep}показывают, что a BiConsumerможет использовать один и тот же тип как для общих параметров, так Tи для Uобщих параметров.  
Реализация предиката и бипредиката
Вы использовали Predicateс OCA, и вы видели это снова позже removeIf()в главе 3. Predicateчасто используется при фильтрации или сопоставлении. Оба очень распространенные операции. A BiPredicateпохож на a, Predicateза исключением того, что он принимает два параметра вместо одного. Опуская любой defaultили staticметоды, интерфейсы определяются следующим образом:

@FunctionalInterface public class Predicate<T> {  
 boolean test(T t);
}
@FunctionalInterface public class BiPredicate<T, U> { 
  boolean test(T t, U u);
}
Это должно быть старые новости, теперь вы можете использовать Predicateдля проверки условия:

Predicate<String> p1 =  String::isEmpty;
Predicate<String> p2 = x -> x.isEmpty(); 
System.out.println(p1.test(""));
System.out.println(p2.test(""));
Это печатает trueдважды. Более интересным является BiPredicate. Этот пример также печатает trueдважды:

BiPredicate<String, String> b1 =  String::startsWith;
BiPredicate<String, String> b2 = (string, prefix) -> string.startsWith(prefix);
 System.out.println(b1.test("chicken", "chick"));
System.out.println(b2.test("chicken", "chick"));
Ссылка на метод объединяет две техники, которые вы уже видели. startsWith()это метод экземпляра. Это означает, что первый параметр в лямбда-выражении используется в качестве экземпляра для вызова метода. Второй параметр передается самому startsWith()методу. Это еще один пример того, как ссылки на методы сохраняют много текста. Недостатком является то, что они менее явные, и вы действительно должны понимать, что происходит!    
 Методы по умолчанию на функциональных интерфейсах
По определению все функциональные интерфейсы имеют один абстрактный метод. Это не значит, что у них есть только один метод. Несколько общих функциональных интерфейсов предоставляют ряд полезных defaultметодов. Вам не нужно знать их для экзамена, но они полезны, когда вы начинаете создавать свои собственные реализации в реальном мире.
Предположим, что у нас есть эти два Predicateс:Predicate<String> egg = s -> s.contains("egg");

Predicate<String> egg = s -> s.contains("egg");
Predicate<String> brown = s -> s.contains("brown");
Теперь мы хотим Predicateдля коричневых яиц и еще один для всех других цветов яиц. Мы могли бы написать это вручную:

Predicate<String> brownEggs = s -> s.contains("egg") && s.contains("brown");
Predicate<String> otherEggs = s -> s.contains("egg") && ! s.contains("brown");
Это работает, но это не здорово. Это немного долго читать, и он содержит дублирование. Что если мы решим, что буква е должна быть написана заглавными буквами в яйцах ? Мы должны были бы изменить его в трех переменных: egg, brownEggs, и otherEggs.
Лучший способ справиться с этой ситуацией - использовать два defaultметода Predicate:

Predicate<String> brownEggs = egg.and(brown);
Predicate<String> otherEggs = egg.and(brown.negate());
Ухоженная! Теперь мы повторно используем логику в оригинальных Predicates для создания двух новых. Короче и понятнее, каковы отношения между Predicateс. Мы также можем изменить орфографию яйца в одном месте, и у двух других объектов будет новая логика, потому что они ссылаются на нее. 
 Реализация функции и BiFunctionFunction
Отвечает за превращение одного параметра в значение потенциально различного типа и вернуть его. Аналогично, a BiFunctionотвечает за преобразование двух параметров в значение и его возврат. Опуская любой defaultили staticметоды, интерфейсы определяются следующим образом:

@FunctionalInterface public class Function<T, R> { 
  R apply(T t);
}
@FunctionalInterface public class BiFunction<T, U, R> { 
  R apply(T t, U u);
}

Например, эта функция преобразует a Stringв длину String:

Function<String, Integer> f1 =  String::length;
Function<String, Integer> f2 = x -> x.length();
 System.out.println(f1.apply("cluck"));  // 5
System.out.println(f2.apply("cluck"));  // 5
Эта функция превращает Stringв Integer. Ну, технически это превращает Stringв int, который автоматически помещается в Integer. Типы не должны быть разными. Следующее объединяет два Stringобъекта и создает другой String:

BiFunction<String, String, String> b1 =  String::concat;
BiFunction<String, String, String> b2 = (string, toAdd) -> string.concat(toAdd); 
System.out.println(b1.apply("baby ", "chick")); // baby chick
System.out.println(b2.apply("baby ", "chick")); // baby chick
Первые два типа BiFunctionявляются типами ввода. Третий тип результата. Для ссылки на метод первый параметр является экземпляром, который concat()вызывается, а второй передается concat().
Создание ваших собственных функциональных интерфейсов
Java предоставляет встроенный интерфейс для функций с одним или двумя параметрами. Что делать, если вам нужно больше? Нет проблем. Предположим, что вы хотите создать функциональный интерфейс для скорости вращения каждого колеса в трехколесном велосипеде. Вы можете создать функциональный интерфейс, такой как этот:
interface TriFunction<T,U,V,R> {
   R apply(T t, U u, V v);
}
Есть четыре типа параметров. Первые три обеспечивают типы скоростей трех колес. Четвертый тип возврата. Теперь предположим, что вы хотите создать функцию, определяющую, насколько быстро работает ваш квадрокоптер с учетом мощности четырех двигателей. Вы можете создать функциональный интерфейс, например:
interface QuadFunction<T,U,V,W,R> { 
  R apply(T t, U u, V v, W w);
}
Здесь есть пять типов параметров. Первые четыре снабжают типами четыре мотора. В идеале это будет тот же тип, но вы никогда не знаете. Пятый тип возврата.
Встроенные интерфейсы Java предназначены для облегчения наиболее распространенных функциональных интерфейсов, которые вам понадобятся. Это ни в коем случае не исчерпывающий список. Помните, что вы можете добавлять любые функциональные интерфейсы, которые захотите, и Java соответствует им, когда вы используете лямбда-выражения или ссылки на методы. 
 Реализация UnaryOperator и BinaryOperator
UnaryOperatorи BinaryOperatorявляются частным случаем функции. Они требуют, чтобы все параметры типа были одного типа. A UnaryOperatorпреобразует свое значение в один и тот же тип. Например, увеличение на единицу является унарной операцией. На самом деле, UnaryOperatorрасширяется Function. A BinaryOperatorобъединяет два значения в одно и того же типа. Добавление двух чисел является двоичной операцией. Точно так же BinaryOperatorрасширяется BiFunction. Опуская любой defaultили staticметоды, интерфейсы определяются следующим образом:

@FunctionalInterface public class UnaryOperator<T> 
   extends Function<T, T> { }
@FunctionalInterface public class BinaryOperator<T>  
  extends BiFunction<T, T, T> { }
Это означает, что сигнатуры методов выглядят так:

T apply(T t);
T apply(T t1, T t2);
Если вы посмотрите на Javadoc, вы заметите, что эти методы фактически объявлены в Function/ BiFunctionсуперклассе. Общие объявления в подклассе заставляют тип быть одинаковым. Для унарного примера обратите внимание, что тип возвращаемого значения совпадает с типом параметра:

UnaryOperator<String> u1 =  String::toUpperCase;
UnaryOperator<String> u2 = x -> x.toUpperCase();
 System.out.println(u1.apply("chirp"));
System.out.println(u2.apply("chirp"));
Это печатает CHIRPдважды. Нам не нужно указывать тип возвращаемого значения в шаблонах, потому что UnaryOperatorон должен совпадать с параметром. А теперь для двоичного примера:

BinaryOperator<String> b1 =  String::concat;
BinaryOperator<String> b2 = (string, toAdd) -> string.concat(toAdd);
 System.out.println(b1.apply("baby ", "chick")); // baby chick
System.out.println(b2.apply("baby ", "chick")); // baby chick
Обратите внимание, что это делает то же самое, что и в BiFunctionпримере. Код более лаконичен, что показывает важность использования правильного функционального интерфейса. Хорошо иметь один общий тип вместо трех.
  Проверка функциональных интерфейсовОчень важно знать количество параметров, типов, возвращаемого значения и имени метода для каждого из функциональных интерфейсов. Сейчас самое время запомнить Таблицу 4.1, если вы еще этого не сделали. Давайте сделаем несколько примеров для практики.
Какой функциональный интерфейс вы бы использовали в этих трех ситуациях?
•	Возвращает Stringбез каких-либо параметров
•	Возвращает Booleanи принимаетString
•	Возвращает Integerи занимает два Integerс
Готов? Подумайте о своем ответе, прежде чем продолжить. В самом деле. Вы должны знать этот холод. ХОРОШО. Первый - это Supplierпотому, что он генерирует объект и принимает нулевые параметры. Второй - Functionпотому что он принимает один параметр и возвращает другой тип. Это немного сложно. Вы можете подумать, что это Predicate. Обратите внимание, что a Predicateвозвращает booleanпримитив, а не Booleanобъект. Наконец, третий - это BinaryOperatorили BiFunction. Поскольку BinaryOperatorэто частный случай BiFunction, либо правильный ответ. BinaryOperatorэто лучший ответ из двух, поскольку он более конкретен.
Давайте попробуем это упражнение снова, но с кодом. С кодом сложнее. С помощью кода первое, что вы делаете, это смотрите, сколько параметров принимает лямбда и есть ли возвращаемое значение. Какой функциональный интерфейс вы бы использовали, чтобы заполнить пробел для них?

6:   _____<List> ex1 = x -> "".equals(x.get(0));
7:   _____<Long> ex2 = (Long l) -> System.out.println(l);
8:   _____ <String, String> ex3 = (s1, s2) -> false;
Опять же, подумайте над ответами, прежде чем продолжить. Готов? Строка 6 передает один Stringпараметр в лямбду и возвращает a boolean. Это говорит нам о том, что это Predicateили Function. Поскольку универсальное объявление имеет только один параметр, это a Predicate.
Строка 7 передает один Longпараметр в лямбду и ничего не возвращает. Это говорит нам о том, что это Consumer. Строка 8 принимает два параметра и возвращает a boolean. Когда вы видите booleanвозвращенное, подумайте, Predicateесли в обобщениях не указан Booleanтип возврата. В этом случае есть два параметра, так что это BiPredicate.
Вы находите это легко? Если нет, пересмотрите Таблицу 4.1 еще раз. Мы не шутим. Вам нужно знать таблицу очень хорошо. Теперь, когда вы только начали изучать таблицу, мы будем играть в «выявить ошибку». Это должно быть сложно:

6:   Function<List<String>> ex1 = x -> x.get(0); // DOES NOT COMPILE
7:   UnaryOperator<Long> ex2 = (Long l) -> 3.14; // DOES NOT COMIPLE
8:   Predicate ex4 = String::isEmpty;  // DOES NOT COMPILE
Строка 6 утверждает, что Function. Для A Functionнеобходимо указать два обобщенных типа - тип входного параметра и тип возвращаемого значения. Тип возвращаемого значения отсутствует в строке 6, из-за чего код не компилируется. Строка 7 - это a UnaryOperator, которая возвращает тот же тип, в котором она была передана. В примере возвращается a, doubleа не a Long, в результате чего код не компилируется.
В строке 8 отсутствует общий для Predicate. Это делает параметр, который был передан, Objectа не String. Лямбда ожидает, Stringпотому что она вызывает метод, который существует, Stringа не Object. Поэтому он не компилируется.
 
 
4)Возврат необязательно 

Предположим, что вы проходите вводный урок Java и получите оценки 90 и 100 на первых двух экзаменах. Теперь мы спрашиваем вас, какова ваша средняя. Среднее значение рассчитывается путем сложения баллов и деления на количество баллов, поэтому вы получите (90 + 100) / 2. Это дает 190/2, поэтому вы отвечаете с 95. Отлично!
Теперь предположим, что вы проходите второй урок по Java, и это первый день занятий. Мы спрашиваем вас, каков ваш средний уровень в этом классе, который только начался. Вы еще не сдавали экзамены, поэтому вам нечего усреднять. Было бы неправильно сказать, что ваше среднее значение равно нулю. Это звучит плохо, и это не правда. Данных просто нет, поэтому у вас пока нет среднего значения.
Как мы выражаем этот ответ «мы не знаем» или «не применим» на Java? Начиная с Java 8, мы используем Optionalтип. An Optionalсоздается с использованием фабрики. Вы можете запросить пустое значение Optionalили передать значение для Optionalпереноса. Думайте о Optionalкак о коробке, в которой может быть что-то или она может быть пустой. На рисунке 4.1 показаны оба варианта.

Рисунок 4.1 Optional
Вот как кодировать наш средний метод:


10:   public static Optional<Double> average(int… scores) {
11:      if (scores.length == 0) return Optional.empty();
12:      int sum = 0;
13:      for (int score: scores) sum += score;
14:      return Optional.of((double) sum / scores.length);
15:   }
Строка 11 возвращает пустое значение, Optionalкогда мы не можем вычислить среднее значение. Строки 12 и 13 складывают оценки. Существует функциональный способ программирования этой математики, но мы вернемся к этому позже в этой главе. Фактически, весь метод может быть записан в одну строку, но это не научит вас, как Optionalработает! Линия 14 создает, Optionalчтобы обернуть среднее.
Вызов метода показывает, что находится в наших двух полях:

System.out.println(average(90, 100)); // Optional[95.0]
System.out.println(average());        // Optional.empty
Вы можете видеть, что один Optionalсодержит значение, а другой пустой. Обычно мы хотим проверить, есть ли значение и / или получить его из коробки. Вот один из способов сделать это:

20:   Optional<Double> opt = average(90, 100);
21:   if (opt.isPresent())
22:      System.out.println(opt.get()); // 95.0
Строка 21 проверяет, Optionalдействительно ли содержит значение. Линия 22 распечатывает это. Что делать, если мы не сделали проверку, и она Optionalбыла пуста?

26:   Optional<Double> opt = average();
27:   System.out.println(opt.get());  // bad
Мы получили бы исключение, так как внутри Optional:

java.util.NoSuchElementException: No value present
При создании Optional, обычно хочется использовать, emptyкогда значение равно null. Вы можете сделать это с помощью ifоператора или троичного оператора. Мы используем троичный оператор, чтобы убедиться, что вы помните, как он работает из ОСА:

Optional o = (value== null) ? Optional.empty(): Optional.of(value);
Если valueесть null, oназначается пустое Optional. В противном случае мы оборачиваем значение. Поскольку это такой распространенный шаблон, Java предоставляет метод фабрики для того же:

Optional o = Optional.ofNullable(value);
Это охватывает статические методы, о которых вам нужно знать Optional. В таблице 4.2 приведены большинство методов экземпляров, Optionalкоторые вам необходимо знать для сдачи экзамена. Есть несколько других, которые связаны с цепочкой. Мы рассмотрим это позже в этой главе.
Таблица 4.2 Optional Методы экземпляра

метод	Когда Optionalпусто	Когда OptionalСодержит Значение
get()	Бросает исключение	Возвращает значение
ifPresent(Consumer c)	Ничего не делает	Звонит Потребителю cсо значением
isPresent()	Возвращает false	Возвращает true
orElse(T other)	Возвращает otherпараметр	Возвращает значение
orElseGet(Supplier s)	Возвращает результат вызова  Supplier	Возвращает значение
orElseThrow(Supplier s)	Выдает исключение, созданное вызовом Supplier	Возвращает значение

Вы уже видели get()и isPresent(). Другие методы позволяют вам писать код, который использует Optionalодну строку без необходимости использования тернарного оператора. Это облегчает чтение кода. Вместо того, чтобы использовать ifоператор, который мы использовали при проверке среднего ранее, мы можем указать a, Consumerкоторый будет выполняться, когда есть значение внутри Optional. Когда нет, метод просто пропускает выполнение Consumer:

Optional<Double> opt = average(90, 100);
opt.ifPresent(System.out::println);
Использование ifPresent()лучше выражает наши намерения. Мы хотим что-то сделать, если значение присутствует. Другие методы позволяют вам указать, что делать, если значение отсутствует. Есть три варианта:

30:   Optional<Double> opt = average();
31:   System.out.println(opt.orElse(Double.NaN));
32:   System.out.println(opt.orElseGet(() -> Math.random()));
33:   System.out.println(opt.orElseThrow(() -> new IllegalStateException()));
Это печатает что-то вроде следующего:

NaN
0.49775932295380165
Exception in thread "main" java.lang.IllegalStateException   
 at optional.Average.lambda$3(Average.java:56)   
 at optional.Average$$Lambda$5/455659002.get(Unknown Source)   
 at java.util.Optional.orElseThrow(Optional.java:290)
Строка 31 показывает, что вы можете вернуть определенное значение или переменную. В нашем случае мы печатаем значение «не число». В строке 32 показано использование a Supplierдля генерации значения во время выполнения для возврата. Я рад, что наши профессора не дали нам случайное среднее значение, хотя! Строка 33 показывает использование другого Supplierдля создания исключения, которое должно быть выброшено. Помните, что трассировка стека выглядит странно, потому что лямбда-выражения генерируются, а не именуются классы.
Обратите внимание, что два метода Supplierимеют разные имена. Вы понимаете, почему этот код не компилируется?

System.out.println(opt.orElseGet( 
 () -> new IllegalStateException())); // DOES NOT COMPILE
optявляется Optional<Double>. Это означает, что Supplierдолжен вернуть Double. Поскольку этот поставщик возвращает исключение, тип не соответствует.
Последний пример с Optionalдействительно прост. Как вы думаете, что это делает?

Optional<Double> opt = average(90, 100);
System.out.println(opt.orElse(Double.NaN));
System.out.println(opt.orElseGet(() -> Math.random()));
System.out.println(opt.orElseThrow(() -> new IllegalStateException()));
Распечатывается 95три раза. Поскольку значение существует, нет необходимости использовать логику «или иначе».
Является ли Optional таким же, как null ?
До Java 8 программисты возвращались nullвместо Optional. У этого подхода было несколько недостатков. Одна заключалась в том, что не было четкого способа выразить это, nullвозможно, особую ценность. Напротив, возвращение Optionalв API является четким утверждением о том, что там может не быть значения.
Еще одним преимуществом Optionalявляется то, что вы можете использовать функциональный стиль программирования с ifPresent()другими методами, а не с помощью ifоператора. Наконец, в конце главы вы увидите, что вы можете связывать Optionalвызовы.


